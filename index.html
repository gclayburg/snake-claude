<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            touch-action: none; /* Disable browser handling of all panning and zooming gestures */
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #gameArea {
            position: relative;
            width: 404px;
            height: 404px;
        }

        canvas {
            border: 2px solid #000;
            display: block;
            /* This removes any extra space below the canvas */
        }

        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 404px;
            height: 404px;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            text-align: center;
        }

        #gameOverlay p {
            margin: 10px 0;
        }

        #sidePanel {
            display: flex;
            flex-direction: column;
            width: 404px; /* Match the width of the game area */
            margin-top: 20px; /* Add some space between game area and touch log */
        }

        #topScoresBox {
            display: none; /* Hide the top 10 list */
        }

        #touchLog {
            display: none; /* Hide by default */
            width: 100%;
            margin-top: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
        }

        #touchLog.show {
            display: block; /* Show when this class is present */
        }

        #touchLog h3 {
            margin-top: 0;
            text-align: center;
        }

        #touchLogList {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        #touchLogList li {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        #gameInstructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
        }

        #overlayText {
            text-align: left;
            white-space: pre-wrap;
            padding: 0 20px;
        }

        .current-score {
            color: green;
            font-weight: bold;
        }

        #controlInstructions {
            position: absolute;
            top: calc(25% - 30px);
            /* Moved 30px higher */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
            white-space: pre-line;
            width: 250px;
        }

        #startButton {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 12px;
            transition-duration: 0.4s;
        }

        #startButton:hover {
            background-color: #45a049;
        }

        #initialsInputContainer {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }

        #initialsInput {
            font-family: 'Courier New', monospace;
            font-size: 24px;
            letter-spacing: 10px;
            text-align: center;
            position: relative;
            margin-right: 10px;
            width: 90px;
            height: 40px;
            border: 2px solid #000;
            border-radius: 5px;
            background-color: #fff;
            color: #000;
        }

        #initialsInput::placeholder {
            color: #999;
            letter-spacing: 10px;
        }

        #okButton {
            font-size: 18px;
            padding: 10px 15px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            height: 44px;
            /* Match the height of the input field */
        }

        #okButton:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* If you have any other interactive elements, you might need to re-enable touch actions for them */
        button, input {
            touch-action: auto;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="gameArea">
            <canvas id="gameCanvas" width="404" height="404"></canvas>
            <div id="gameOverlay">
                <p id="overlayText"></p>
                <div id="initialsInputContainer">
                    <input type="text" id="initialsInput" maxlength="3" autocomplete="off" placeholder="___" />
                    <button id="okButton" disabled>OK</button>
                </div>
                <p id="currentScore"></p>
                <p id="highScore"></p>
            </div>
            <button id="startButton">Press space bar to start</button>
            <div id="controlInstructions"></div>
        </div>
        <div id="sidePanel">
            <div id="touchLog">
                <h3>Touch Log</h3>
                <ul id="touchLogList"></ul>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('gameOverlay');
        const currentScoreElement = document.getElementById('currentScore');
        const highScoreElement = document.getElementById('highScore');
        const overlayText = document.getElementById('overlayText');
        const topScoresList = document.getElementById('topScoresList');
        const gameInstructions = document.getElementById('gameInstructions');
        const controlInstructions = document.getElementById('controlInstructions');
        const startButton = document.getElementById('startButton');
        const initialsInput = document.getElementById('initialsInput');
        const okButton = document.getElementById('okButton');
        const touchLogList = document.getElementById('touchLogList');

        const gridSize = 20;
        const tileCount = 20; // Change this line

        let snake = [
            { x: 10, y: 10 },
        ];
        let food = { x: 15, y: 15 };
        let dx = 0;
        let dy = -1;
        let score = 0;
        let highScore = 0;
        let gameOver = false;
        let gameState = 'initial';

        let highScores = [];
        let isNewHighScore = false;
        let currentInitials = '';
        let currentPlayerScore = null;

        let nextDirection = { dx: 0, dy: -1 };
        let inputQueue = [];
        let updateInterval = 100; // Adjust this value to change the snake's speed (higher = slower)
        let loopCount = 0;

        function initGame() {
            snake = [{ x: Math.floor(tileCount / 2), y: tileCount - 1 }];
            food = { x: 15, y: 15 };
            dx = 0;
            dy = -1;
            nextDirection = { dx: 0, dy: -1 };
            score = 0;
            gameOver = false;
            gameState = 'initial';
            loadHighScores();
            overlay.style.display = 'flex';
            overlayText.textContent = 'Snake Game';
            controlInstructions.textContent = 'Controls:\nLeft arrow / Touch left: turn left\nRight arrow / Touch right: turn right';
            controlInstructions.style.display = 'block';
            currentPlayerScore = null;
            
            // Check if touch log should be shown
            const touchLog = document.getElementById('touchLog');
            if (shouldShowTouchLog()) {
                touchLog.classList.add('show');
            } else {
                touchLog.classList.remove('show');
            }
            
            startButton.style.display = 'block';
            initialsInput.style.display = 'none';
            okButton.style.display = 'none'; // Ensure OK button is hidden on init
            addTouchControls();
        }

        function loadHighScores() {
            const savedScores = localStorage.getItem('snakeHighScores');
            highScores = savedScores ? JSON.parse(savedScores) : [];
        }

        function saveHighScores() {
            localStorage.setItem('snakeHighScores', JSON.stringify(highScores));
        }

        function addHighScore(score, initials) {
            currentPlayerScore = { score, initials };
            highScores.push(currentPlayerScore);
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 10);
            saveHighScores();
            updateTopScoresDisplay(true);
        }

        function endGame() {
            gameState = 'gameover';
            gameOver = true;
            isNewHighScore = checkNewHighScore(score);

            if (isNewHighScore) {
                overlayText.textContent = `New high score #${isNewHighScore}!`;
                initialsInput.value = '';
                initialsInput.placeholder = '___';
                initialsInput.style.display = 'block';
                okButton.style.display = 'inline-block';
                okButton.disabled = true;
                currentInitials = '';
            } else {
                showHighScores();
            }
            overlay.style.display = 'flex';
            controlInstructions.textContent = 'Controls:\nLeft arrow / Touch left: turn left\nRight arrow / Touch right: turn right';
            controlInstructions.style.display = 'block';
        }

        function checkNewHighScore(score) {
            if (score === 0) return false; // Don't trigger high score for 0 points
            for (let i = 0; i < highScores.length; i++) {
                if (score > highScores[i].score) {
                    return i + 1;
                }
            }
            return highScores.length < 10 ? highScores.length + 1 : false;
        }

        function showHighScores() {
            overlayText.textContent = 'Game Over!';
            initialsInput.style.display = 'none';
            okButton.style.display = 'none';
            currentScoreElement.textContent = `Your score: ${score}`;
            highScoreElement.textContent = '';
            startButton.textContent = 'Tap to restart';
            startButton.style.display = 'block';
            controlInstructions.style.display = 'block';
        }

        function startGame() {
            gameState = 'starting';

            // Reset game variables
            snake = [{ x: Math.floor(tileCount / 2), y: tileCount - 1 }];
            food = { x: 15, y: 15 };
            dx = 0;
            dy = -1;
            nextDirection = { dx: 0, dy: -1 };
            score = 0;
            gameOver = false;
            currentPlayerScore = null; // Reset the current player score

            // Hide all elements except the canvas and overlay
            startButton.style.display = 'none';
            currentScoreElement.style.display = 'none';
            highScoreElement.style.display = 'none';
            initialsInput.style.display = 'none';
            okButton.style.display = 'none'; // Ensure OK button is hidden when starting a new game

            // Keep the canvas visible but clear it
            clearCanvas();
            drawWalls();

            overlay.style.display = 'flex';

            let countdown = ['Ready', 'Set', 'Go!'];
            let index = 0;

            function updateCountdown() {
                if (index < countdown.length) {
                    overlayText.textContent = countdown[index];
                    index++;
                    setTimeout(updateCountdown, 1000);
                } else {
                    // Show all elements again and start the game
                    overlay.style.display = 'none';
                    controlInstructions.style.display = 'none';
                    gameState = 'playing';
                    canvas.style.touchAction = 'none'; // Disable default touch actions
                    loopCount = 0;
                    requestAnimationFrame(gameLoop);
                }
            }

            updateCountdown();
        }

        function gameLoop() {

            if (gameState === 'playing') {
                console.log('game loop', loopCount++);
                clearCanvas();
                processInputQueue();
                moveSnake();
                drawWalls();
                drawFood();
                drawSnake();
                checkCollision();
                drawScore();
                updateTopScoresDisplay();
                setTimeout(() => requestAnimationFrame(gameLoop), updateInterval)
            }
        }

        function processInputQueue() {
            const input = inputQueue.shift();
            if (input === 'left') {
                console.log('turning left');
                turnLeft();
            } else if (input === 'right') {
                console.log('turning right');
                turnRight();
            }
        }

        function clearCanvas() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawWalls() {
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
        }

        function drawFood() {
            ctx.fillStyle = 'red';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);
        }

        function drawSnake() {
            ctx.fillStyle = 'green';
            snake.forEach(segment => {
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
            });
        }

        function moveSnake() {
            // Apply the nextDirection
            dx = nextDirection.dx;
            dy = nextDirection.dy;

            const head = { x: snake[0].x + dx, y: snake[0].y + dy };
            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score++;
                generateFood();
                updateTopScoresDisplay();
            } else {
                snake.pop();
            }
        }
        /**
         * Generates a new food item for the snake to eat.
         * 
         * This function creates a new food object with random x and y coordinates
         * within the game grid. It ensures that the new food does not appear on
         * any part of the snake's body.
         * 
         * The function uses a do-while loop to repeatedly generate new coordinates
         * until a valid position (not occupied by the snake) is found.
         * 
         * Once a valid position is found, the global 'food' variable is updated
         * with the new coordinates.
         */

        function generateFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));

            food = newFood;
        }

        function checkCollision() {
            const head = snake[0];

            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                endGame();
            }

            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    endGame();
                }
            }
        }

        function drawScore() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}`, 10, 30);
        }

        function turnLeft() {
            if (dx === 0 && dy === -1) { // facing up
                nextDirection = { dx: -1, dy: 0 }; // turn left
            } else if (dx === -1 && dy === 0) { // facing left
                nextDirection = { dx: 0, dy: 1 }; // turn down
            } else if (dx === 0 && dy === 1) { // facing down
                nextDirection = { dx: 1, dy: 0 }; // turn right
            } else if (dx === 1 && dy === 0) { // facing right
                nextDirection = { dx: 0, dy: -1 }; // turn up
            }
        }

        function turnRight() {
            if (dx === 0 && dy === -1) { // facing up
                nextDirection = { dx: 1, dy: 0 }; // turn right
            } else if (dx === 1 && dy === 0) { // facing right
                nextDirection = { dx: 0, dy: 1 }; // turn down
            } else if (dx === 0 && dy === 1) { // facing down
                nextDirection = { dx: -1, dy: 0 }; // turn left
            } else if (dx === -1 && dy === 0) { // facing left
                nextDirection = { dx: 0, dy: -1 }; // turn up
            }
        }

        function updateTopScoresDisplay(gameOver = false) {
            // Check if the topScoresList element exists
            const topScoresList = document.getElementById('topScoresList');
            if (!topScoresList) {
                console.log('Top scores list is hidden or not available');
                return; // Exit the function if the element doesn't exist
            }

            topScoresList.innerHTML = '';
            let currentScoreInserted = false;
            let displayedScores = [...highScores];

            if (!gameOver) {
                // Find where the current score should be inserted
                let insertIndex = displayedScores.findIndex(entry => score > entry.score);
                if (insertIndex === -1 && displayedScores.length < 10) {
                    insertIndex = displayedScores.length;
                }

                if (insertIndex !== -1) {
                    displayedScores.splice(insertIndex, 0, { score, initials: 'YOU' });
                    currentScoreInserted = true;
                }
            }

            displayedScores = displayedScores.slice(0, 10);

            for (let i = 0; i < displayedScores.length; i++) {
                const li = document.createElement('li');
                const scoreEntry = displayedScores[i];

                if (!gameOver && scoreEntry.initials === 'YOU') {
                    li.innerHTML = `${i + 1}. <span class="current-score">YOU - ${scoreEntry.score}</span>`;
                } else {
                    const isCurrentPlayer = currentPlayerScore && scoreEntry.score === currentPlayerScore.score && scoreEntry.initials === currentPlayerScore.initials;
                    if (isCurrentPlayer && gameState !== 'initial') {
                        li.innerHTML = `${i + 1}. <span class="current-score">${scoreEntry.initials} - ${scoreEntry.score}</span>`;
                    } else {
                        li.textContent = `${i + 1}. ${scoreEntry.initials} - ${scoreEntry.score}`;
                    }
                }
                topScoresList.appendChild(li);
            }

            // Fill remaining slots if less than 10 scores
            for (let i = displayedScores.length; i < 10; i++) {
                const li = document.createElement('li');
                li.textContent = `${i + 1}. - - -`;
                topScoresList.appendChild(li);
            }
        }

        function addTouchControls() {
            let lastLeftTapTime = 0;
            let lastRightTapTime = 0;
            const tapThreshold = 250; // milliseconds
            let touchCount = 0;

            // Add the event listener to the document instead of the canvas
            document.addEventListener('touchstart', handleTouch, false);
            document.addEventListener('touchend', handleTouchEnd, false);

            function handleTouch(event) {
                touchCount++;
                event.preventDefault();
                const currentTime = new Date().getTime();
                
                // Use the last touch point
                const touch = event.touches[event.touches.length - 1];
                const screenWidth = window.innerWidth;
                const touchX = touch.clientX;

                logTouch(`Touch #${touchCount} - Start: ${lastLeftTapTime} ${lastRightTapTime}`, currentTime);

                if (gameState === 'playing') {
                    if (touchX < screenWidth / 2) {
                        // Left side touch
                        const leftDiff = currentTime - lastLeftTapTime;
                        logTouch(`  Left check: diff=${leftDiff}, threshold=${tapThreshold}`, currentTime);
                        if (leftDiff > tapThreshold) {
                            logTouch(`  Left action: Pushing 'left' to queue`, currentTime);
                            if (inputQueue.length === 0 || inputQueue[inputQueue.length - 1] !== 'left') {
                                inputQueue.push('left');
                                logTouch(`    'left' added to queue`, currentTime);
                            } else {
                                logTouch(`    'left' not added (duplicate)`, currentTime);
                            }
                            lastLeftTapTime = currentTime;
                            logTouch(`  Updated lastLeftTapTime: ${lastLeftTapTime}`, currentTime);
                        } else {
                            logTouch(`  Left action skipped (too soon)`, currentTime);
                        }
                    } else {
                        // Right side touch
                        const rightDiff = currentTime - lastRightTapTime;
                        logTouch(`  Right check: diff=${rightDiff}, threshold=${tapThreshold}`, currentTime);
                        if (rightDiff > tapThreshold) {
                            logTouch(`  Right action: Pushing 'right' to queue`, currentTime);
                            if (inputQueue.length === 0 || inputQueue[inputQueue.length - 1] !== 'right') {
                                inputQueue.push('right');
                                logTouch(`    'right' added to queue`, currentTime);
                            } else {
                                logTouch(`    'right' not added (duplicate)`, currentTime);
                            }
                            lastRightTapTime = currentTime;
                            logTouch(`  Updated lastRightTapTime: ${lastRightTapTime}`, currentTime);
                        } else {
                            logTouch(`  Right action skipped (too soon)`, currentTime);
                        }
                    }
                } else if (gameState === 'initial' || gameState === 'gameover') {
                    logTouch(`  Game not playing, starting game`, currentTime);
                    startGame();
                }

                logTouch(`Touch #${touchCount} - End: ${lastLeftTapTime} ${lastRightTapTime}`, currentTime);
                logTouch(`Current inputQueue: ${JSON.stringify(inputQueue)}`, currentTime);
            }

            function handleTouchEnd(event) {
                // Reset lastLeftTapTime and lastRightTapTime when all fingers are lifted
                if (event.touches.length === 0) {
                    lastLeftTapTime = 0;
                    lastRightTapTime = 0;
                    logTouch('All touches ended, reset tap times', new Date().getTime());
                }
            }

            // Add this function at the beginning of your script, outside any other function
            function getCurrentTimestamp() {
                return new Date().toISOString().split('T')[1].slice(0, -1);
            }

            // Modify the logTouch function
            function logTouch(message, timestamp) {
                if (!shouldShowTouchLog()) return; // Exit if touch log shouldn't be shown

                const formattedTimestamp = getCurrentTimestamp();
                const logEntry = `${formattedTimestamp} - ${message}`;
                
                const li = document.createElement('li');
                li.textContent = logEntry;
                touchLogList.insertBefore(li, touchLogList.firstChild);
                
                // Keep only the last 50 entries
                while (touchLogList.children.length > 50) {
                    touchLogList.removeChild(touchLogList.lastChild);
                }

                // Also log to console for easier debugging
                console.log(logEntry);
            }
        }

        function shouldShowTouchLog() {
            return window.location.hash === '#showtouchlog';
        }

        window.addEventListener('hashchange', function() {
            const touchLog = document.getElementById('touchLog');
            if (shouldShowTouchLog()) {
                touchLog.classList.add('show');
            } else {
                touchLog.classList.remove('show');
            }
        });

        document.addEventListener('keydown', (e) => {
            if ((gameState === 'initial' || gameState === 'gameover') && e.code === 'Space') {
                startGame();
                return;
            }

            if (gameState === 'gameover') {
                if (isNewHighScore) {
                    if (e.key.length === 1 && /[a-zA-Z]/.test(e.key) && currentInitials.length < 3) {
                        currentInitials += e.key.toUpperCase();
                        updateInitialsDisplay();
                    } else if (e.key === 'Enter' && currentInitials.length === 3) {
                        submitHighScore();
                    } else if (e.key === 'Backspace') {
                        currentInitials = currentInitials.slice(0, -1);
                        updateInitialsDisplay();
                    }
                } else if (e.code === 'Space') {
                    initGame();
                    startGame();
                }
                return;
            }

            if (gameState !== 'playing') return;

            switch (e.key) {
                case 'ArrowLeft':
                    console.log('  go left');
                    inputQueue.push('left');
                    break;
                case 'ArrowRight':
                    console.log('  go right');
                    inputQueue.push('right');
                    break;
            }
        });

        function updateInitialsDisplay() {
            initialsInput.value = currentInitials.padEnd(3, '_');
            const charWidth = 24; // Width of each character (including letter-spacing)
            const cursorPosition = currentInitials.length * charWidth;
            initialsInput.style.setProperty('--cursor-position', `${cursorPosition}px`);

            // Enable or disable the OK button based on initials length
            okButton.disabled = currentInitials.length !== 3;
        }

        function submitHighScore() {
            addHighScore(score, currentInitials);
            isNewHighScore = false;
            showHighScores();
        }

        initialsInput.addEventListener('input', function (e) {
            let newValue = this.value.toUpperCase();

            // Ensure we only have letters
            newValue = newValue.replace(/[^A-Z]/g, '');

            // Limit to 3 characters
            newValue = newValue.slice(0, 3);

            // Update the input value
            this.value = newValue;
            currentInitials = newValue;

            // Enable/disable OK button
            okButton.disabled = newValue.length !== 3;

            // Update placeholder based on input
            this.placeholder = '_'.repeat(Math.max(0, 3 - newValue.length));
        });

        initialsInput.addEventListener('keydown', function (e) {
            if (e.key === 'Backspace' && this.selectionStart === this.selectionEnd) {
                // If cursor is at the end, just let the default behavior happen
                if (this.selectionStart === this.value.length) return;

                // Prevent default backspace behavior
                e.preventDefault();

                // Remove the character before the cursor
                const cursorPos = this.selectionStart;
                this.value = this.value.slice(0, cursorPos - 1) + this.value.slice(cursorPos);

                // Move the cursor back
                this.setSelectionRange(cursorPos - 1, cursorPos - 1);

                // Trigger input event to update state
                this.dispatchEvent(new Event('input'));
            }
        });

        initialsInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter' && this.value.length === 3) {
                submitHighScore();
            }
        });

        okButton.addEventListener('click', function () {
            if (currentInitials.length === 3) {
                submitHighScore();
            }
        });

        startButton.addEventListener('click', () => {
            if (gameState === 'initial' || gameState === 'gameover') {
                startGame();
            }
        });

        initGame(); // Call this at the end of the script
    </script>
</body>

</html>